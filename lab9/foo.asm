#MIPS code generated by CS370

.data
_L0: .asciiz	 "Please enter number "
_L1: .asciiz	 ": "
_L2: .asciiz	 "Square of "
_L3: .asciiz	 " is: "
_L4: .asciiz	 " (Result is greater than 25)"
_L5: .asciiz	 "\n"

.align 2

globalCount: .space 4	 #global variable

.text


.globl main


square:			## function definition
	move $a1, $sp		#Activation Record carve out copy SP
	subi $a1, $a1, 16		#Activation Record carve out copy size of function
	sw $ra, ($a1)		#Save the return address
	sw $sp 4($a1)		#Store old Stack Pointer
	move $sp, $a1		#Make SP the current activation record


	sw $t0 8($sp)		#Store the parameter in the activation record


	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 8		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	sw $a0, 12($sp)		#Expression store LHS temporarily
	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 8		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	move $a1, $a0		#right hand side needs to be a1
	lw $a0, 12($sp)		#Expression restore LHS from memory
	mult $a0 $a1		#Multiplication
	mflo $a0		#Multiplication
	lw $ra ($sp)		#restore old environement RA
	lw $sp 4($sp)		#Return from function store SP

	jr $ra		#return to caller
	li $a0, 0		#RETURN has no specified value set to 0
	lw $ra, ($sp)		#Restore old enviornment RA
	lw $sp, 4($sp)		#Return from function store SP


	jr $ra		#return to caller
	
			#End of function


main:			## function definition
	move $a1, $sp		#Activation Record carve out copy SP
	subi $a1, $a1, 76		#Activation Record carve out copy size of function
	sw $ra, ($a1)		#Save the return address
	sw $sp 4($a1)		#Store old Stack Pointer
	move $sp, $a1		#Make SP the current activation record




	li $a0, 5		#expression is a constant
	sw $a0, 36($sp)		#Assign store RHS temporarily
	la $a0, globalCount		#EMIT var global variable
	lw $a1, 36($sp)		#Assign get RHS temporarily
	sw $a1, ($a0)		#Assign place RHS into mempory
	li $a0, 0		#expression is a constant
	sw $a0, 40($sp)		#Assign store RHS temporarily
	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a1, 40($sp)		#Assign get RHS temporarily
	sw $a1, ($a0)		#Assign place RHS into mempory
_L6:			## Start of while loop
	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	sw $a0, 44($sp)		#Expression store LHS temporarily
	la $a0, globalCount		#EMIT var global variable
	lw $a0, ($a0)		#expression is a var
	move $a1, $a0		#right hand side needs to be a1
	lw $a0, 44($sp)		#Expression restore LHS from memory
	slt $a0, $a0, $a1		#Less than
	beq $a0, $0, _L7		## End of while loop
	la $a0, _L0		#Load the address of the string
	li $v0, 4		#About to print a string
	syscall			#call write string


	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	li $v0, 1		#About to print a number
	syscall			#call write number


	la $a0, _L1		#Load the address of the string
	li $v0, 4		#About to print a string
	syscall			#call write string


	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	move $a1, $a0		# VAR copy index array in a1
	sll $a1 $a1 2		# muliply the index by wordszie via SLL
	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 8		#VAR local stack pointer plus offset
	add $a0, $a0, $a1		#VAR add index to address
	li $v0, 5		#About to read a value
	syscall			#read in value -- $v0 now has the read in value
	sw $v0, ($a0)		#store the value in the variable


	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	sw $a0, 48($sp)		#Expression store LHS temporarily
	li $a0, 1		#expression is a constant
	move $a1, $a0		#right hand side needs to be a1
	lw $a0, 48($sp)		#Expression restore LHS from memory
	add $a0, $a0, $a1		#Addition
	sw $a0, 52($sp)		#Assign store RHS temporarily
	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a1, 52($sp)		#Assign get RHS temporarily
	sw $a1, ($a0)		#Assign place RHS into mempory
	j _L6		## Jump back to start of while loop
_L7:			##`End of while loop
	li $a0, 0		#expression is a constant
	sw $a0, 48($sp)		#Assign store RHS temporarily
	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a1, 48($sp)		#Assign get RHS temporarily
	sw $a1, ($a0)		#Assign place RHS into mempory
_L8:			## Start of while loop
	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	sw $a0, 52($sp)		#Expression store LHS temporarily
	la $a0, globalCount		#EMIT var global variable
	lw $a0, ($a0)		#expression is a var
	move $a1, $a0		#right hand side needs to be a1
	lw $a0, 52($sp)		#Expression restore LHS from memory
	slt $a0, $a0, $a1		#Less than
	beq $a0, $0, _L9		## End of while loop
			# Setting Up Function Call
			# Evaluate function arguments
			# place Parameters into T registers

	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	move $a1, $a0		# VAR copy index array in a1
	sll $a1 $a1 2		# muliply the index by wordszie via SLL
	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 8		#VAR local stack pointer plus offset
	add $a0, $a0, $a1		#VAR add index to address
	lw $a0, ($a0)		#expression is a var
	sw $a0, 56($sp)		## Store argument
	lw $a0, 56($sp)		## Retrieve argument
	move $t0, $a0		## Move argument to register
	jal square		## Function call

	sw $a0, 60($sp)		#Assign store RHS temporarily
	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 32		#VAR local stack pointer plus offset
	lw $a1, 60($sp)		#Assign get RHS temporarily
	sw $a1, ($a0)		#Assign place RHS into mempory
	la $a0, _L2		#Load the address of the string
	li $v0, 4		#About to print a string
	syscall			#call write string


	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	move $a1, $a0		# VAR copy index array in a1
	sll $a1 $a1 2		# muliply the index by wordszie via SLL
	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 8		#VAR local stack pointer plus offset
	add $a0, $a0, $a1		#VAR add index to address
	lw $a0, ($a0)		#expression is a var
	li $v0, 1		#About to print a number
	syscall			#call write number


	la $a0, _L3		#Load the address of the string
	li $v0, 4		#About to print a string
	syscall			#call write string


	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 32		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	li $v0, 1		#About to print a number
	syscall			#call write number


	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 32		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	sw $a0, 64($sp)		#Expression store LHS temporarily
	li $a0, 25		#expression is a constant
	move $a1, $a0		#right hand side needs to be a1
	lw $a0, 64($sp)		#Expression restore LHS from memory
	sgt $a0, $a0, $a1		#Greater than
	beq $a0, $0, _L10		#End of if statement
	
		#Start of else statement
	la $a0, _L4		#Load the address of the string
	li $v0, 4		#About to print a string
	syscall			#call write string


	j _L11		#s1 END
_L10:			#ELSE TARGET
			#otherwise just these lines
			#End of then statement
_L11:			#End of if statement
	la $a0, _L5		#Load the address of the string
	li $v0, 4		#About to print a string
	syscall			#call write string


	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a0, ($a0)		#expression is a var
	sw $a0, 68($sp)		#Expression store LHS temporarily
	li $a0, 1		#expression is a constant
	move $a1, $a0		#right hand side needs to be a1
	lw $a0, 68($sp)		#Expression restore LHS from memory
	add $a0, $a0, $a1		#Addition
	sw $a0, 72($sp)		#Assign store RHS temporarily
	move $a0 $sp		#VAR local variable make a copy of SP
	addi $a0, $a0, 28		#VAR local stack pointer plus offset
	lw $a1, 72($sp)		#Assign get RHS temporarily
	sw $a1, ($a0)		#Assign place RHS into mempory
	j _L8		## Jump back to start of while loop
_L9:			##`End of while loop
	li $a0, 0		#RETURN has no specified value set to 0
	lw $ra ($sp)		#restore old environement RA
	lw $sp 4($sp)		#Return from function store SP

	li $v0, 10		#Exit from main we are done
	syscall			#EXIT everything
	li $a0, 0		#RETURN has no specified value set to 0
	lw $ra, ($sp)		#Restore old enviornment RA
	lw $sp, 4($sp)		#Return from function store SP


	li $v0, 10		#Exit from main we are done
	syscall			#EXIT everything
	
			#End of function


