/*

Ryan Lucero
Lab 9 - MIPS Code Generation from AST
CS370 Spring 2024 - Shaun Cooper
4/30/2024

emit.c

UNDERGRAD -> LEVELS a - e


In this file, I have implemented several function that generate MIPS code from the AST.
The core function is EMIT_AST, which is a recursive function that traverses the AST and generates MIPS code for each node.
I have also implemented several helper functions that are called by EMIT_AST to generate the MIPS code for the different
types of nodes in the AST. "emit" is a helper function that prints out MIPS code to the file. "EMIT" is the function that
handles labels for strings and global variables, and calls EMIT_AST to generate the MIPS code. "EMIT_GLOBALS" prints out
MIPS code for global variables. "EMIT_STRINGS" prints out MIPS code for strings. "emit_var" generates MIPS code that determines
if array or local/global variable. "emit_read" generates MIPS code to read in a value and place it in the VAR of read.
"emit_write" generates MIPS code to write out a value. "emit_expr" handles all the expressions and operators. "emit_assign"
generates MIPS code for assignment. "emit_while" generates MIPS code for while loop. "emit_if" generates MIPS code for if statement.
"emit_return" generates MIPS code for return statement. "emit_call" generates MIPS code for function call. "emit_function" generates
MIPS code for function definition.



*/

#include "ast.h"
#include "emit.h"
#include <string.h>
#include <stdlib.h>

// internal prototypes
void EMIT_AST(ASTnode *p, FILE *fp);
void emit_call(ASTnode *p, FILE *fp);


char *currentFunctionName = NULL; //global variable for current function name

// PRE: possible label, command, comment
// POST: formatted output to the file
void emit(FILE *fp, char *label, char *command, char *comment)
{
    {
        if (strcmp("", comment) == 0) // no comment
        {
            if (strcmp("", label) == 0) // no label
            {
                fprintf(fp, "\t%s\t\t\n", command); // no label or comment
            }
            else
            {
                fprintf(fp, "%s:\t%s\t \t\n", label, command); // no comment
            }
        }
        else
        {
            if (strcmp("", label) == 0) // no label
            {
                fprintf(fp, "\t%s\t\t#%s\n", command, comment); // no label
            }
            else
            {
                fprintf(fp, "%s:\t%s\t\t#%s\n", label, command, comment); // all three
            }
        }
    }
}

// PRE : PTR to AST , PTR to FILE
// POST: print out MIPS code into file, using helper functions
void EMIT(ASTnode *p, FILE *fp)
{
    if (p == NULL)
        return;
    if (fp == NULL)
        return;

    // print out the header
    fprintf(fp, "#MIPS code generated by CS370\n\n");
    fprintf(fp, ".data\n");

    EMIT_STRINGS(p, fp);
    fprintf(fp, "\n.align 2\n\n");
    EMIT_GLOBALS(p, fp);
    fprintf(fp, "\n.text\n\n\n");
    fprintf(fp, ".globl main\n\n\n");
    EMIT_AST(p, fp);
}

// PRE:  PTR to top of AST, and FILE ptr to print to
// POST:  prints MIPS based  global variables into file
void EMIT_GLOBALS(ASTnode *p, FILE *fp)
{
    if (p == NULL)
        return;
    if (fp == NULL)
        return;

    if (p->type == A_VARDEC && p->symbol->level == 0) // global variable
    {
        fprintf(fp, "%s: .space %d\t #global variable\n", p->name, p->symbol->mysize * WSIZE);  // print out the global variable with size
    }
    EMIT_GLOBALS(p->s1, fp);
    EMIT_GLOBALS(p->next, fp);
}

// PRE:  PTR to top of AST, and FILE ptr to print to
// POST:  Adds a label into the AST for use string in write statements
// POST:  prints MIPS based  string  into file
void EMIT_STRINGS(ASTnode *p, FILE *fp)
{
    if (p == NULL)
        return;
    if (fp == NULL)
        return;

    if (p->type == A_WRITE && p->name != NULL) // string
    {
        p->label = createLabel(); // p is a string so create a label
        fprintf(fp, "%s: .asciiz\t %s\n", p->label, p->name); // print out the strings
    }
    EMIT_STRINGS(p->s1, fp); // go to expression
    EMIT_STRINGS(p->s2, fp);
    EMIT_STRINGS(p->next, fp);
}

// PRE: PTR to a VAR node
// POST: MIPS code that sets $a0 to the address of VAR
void emit_var(ASTnode *p, FILE *fp)
{
    char s[100];
    if (p->s1 != NULL) // array
    {
        emit_expr(p->s1, fp); // $a0 now has the index
        emit(fp, "", "move $a1, $a0", " VAR copy index array in a1");
        emit(fp, "", "sll $a1 $a1 2", " muliply the index by wordszie via SLL");
    }
    if (p->symbol->level == 0) // global variable
    {
        sprintf(s, "la $a0, %s", p->name);  // load the address of the variable
        emit(fp, "", s, "EMIT var global variable"); // emit the globl variable
    }
    else // local variable
    {
        sprintf(s, "move $a0 $sp"); // copy the stack pointer
        emit(fp, "", s, "VAR local variable make a copy of SP");
        sprintf(s, "addi $a0, $a0, %d", p->symbol->offset * WSIZE); // add $a0, $a0, offset
        emit(fp, "", s, "VAR local stack pointer plus offset");
    }

    if (p->s1 != NULL) // array
    {
        emit(fp, "", "add $a0, $a0, $a1", "VAR add index to address"); // add the index to the address    
    }
} // end of emit_var

// PRE: PTR to A_READ
// POST: MIPS code to read in a value and place it in the VAR of read
void emit_read(ASTnode *p, FILE *fp)
{
    char s[100];

    emit_var(p->s1, fp); //$a0 now has the address of the variable
    emit(fp, "", "li $v0, 5", "About to read a value");
    emit(fp, "", "syscall\t", "read in value -- $v0 now has the read in value");
    emit(fp, "", "sw $v0, ($a0)", "store the value in the variable");
    fprintf(fp, "\n\n");

} // end of emit_read

// PRE: PTR to A_WRITE
// POST: MIPS code to write out a value
void emit_write(ASTnode *p, FILE *fp)
{
    char s[100];
    // if we are writing a string
    if (p->name != NULL)
    {
        // need to load the address of the label into $a0
        //  and call print string
        sprintf(s, "la $a0, %s", p->label);
        emit(fp, "", s, "Load the address of the string");
        emit(fp, "", "li $v0, 4", "About to print a string");
        emit(fp, "", "syscall\t", "call write string");
        fprintf(fp, "\n\n");
    } // end of if
    else
    {
        // we are writing an expression
        emit_expr(p->s1, fp);
        emit(fp, "", "li $v0, 1", "About to print a number");
        emit(fp, "", "syscall\t", "call write number");
        fprintf(fp, "\n\n");
    } // end of else

} // end of emit_write

// PRE: PTR to expression familly
// POST: MIPS code that sets $a0 to the value of the expression
void emit_expr(ASTnode *p, FILE *fp)
{
    char s[100];
    // base cases
    switch (p->type)
    {
    case A_NUM:
        sprintf(s, "li $a0, %d", p->value); // load the value into $a0
        emit(fp, "", s, "expression is a constant");
        return;
        break;

    case A_EXPR: // hanled by helper functions
        break;

    case A_VAR:
        emit_var(p, fp); // handled by helper function
        emit(fp, "", "lw $a0, ($a0)", "expression is a var");
        return;
        break;

    case A_CALL:
        emit_call(p, fp); // handled by helper function
        return;
        break;

    default:
        printf("emit_expr switch SHOULD NEVER BE HERE\n");
        printf("FIX FIX FIX\n");
        exit(1);
    } // end of switch

    // experssion
    emit_expr(p->s1, fp); // $a0 has the value of the s1 expression
    sprintf(s, "sw $a0, %d($sp)", p->symbol->offset * WSIZE); // store the value
    emit(fp, "", s, "Expression store LHS temporarily");
    if (p->s2 != NULL)  // if there is a s2 
    {
        emit_expr(p->s2, fp);
        emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
        sprintf(s, "lw $a0, %d($sp)", p->symbol->offset * WSIZE);
        emit(fp, "", s, "Expression restore LHS from memory");

        switch (p->operator)
        { 
        case A_PLUS:
            emit(fp, "", "add $a0, $a0, $a1", "Addition");
            break;

        case A_EQ:
            emit(fp, "", "seq $a0, $a0, $a1", "Equal");
            break;

        case A_MINUS:
            emit(fp, "", "sub $a0, $a0, $a1", "Subtraction");
            break;

        case A_TIMES:
            emit(fp, "", "mult $a0 $a1", "Multiplication");
            emit(fp, "", "mflo $a0", "Multiplication");
            break;

        case A_DIV:
            emit(fp, "", "div $a0, $a1", "Division");
            emit(fp, "", "mflo $a0", "Division");
            break;

        case A_MOD:
            emit(fp, "", "div $a0 $a1", "Modulus");
            emit(fp, "", "mfhi $a0", "Modulus");
            break;

        case A_GT:
            emit(fp, "", "sgt $a0, $a0, $a1", "Greater than");
            break;

        case A_LT:
            emit(fp, "", "slt $a0, $a0, $a1", "Less than");
            break;

        case A_LE:
            emit(fp, "", "add $a1, $a1, 1", "Less than or equal");
            emit(fp, "", "slt $a0, $a0, $a1", "Less than or equal");
            break;

        case A_GE:
            emit(fp, "", "add $a0, $a0, 1", "Greater than or equal");
            emit(fp, "", "slt $a0, $a1, $a0", "Greater than or equal");
            break;

        case A_NE:
            emit(fp, "", "sne $a0, $a1, $a0", "Not equal");
            break;

        default:
            printf("emit_expr operator %d not implemented\n", p->operator);
            printf("WE SHOULD NEVER BE HERE\n");
            exit(1);
        } // end of switch
    }     // end of if
    else // unary operator
    {
        emit(fp, "", "move $a1 $a0", "UNARY");
        emit(fp, "", "li $a0, 0", "UNARY");
        emit(fp, "", "sub $a0, $a0, $a1", "UNARY");
    }

} // end of emit_expr

// PRE: PTR to ASTnode A_ASSIGN
// POST: MIPS code into the file for the tree
void emit_assign(ASTnode *p, FILE *fp)
{
    char s[100];          // array for forming strings
    emit_expr(p->s2, fp); // $a0 has the value of the expression
    sprintf(s, "sw $a0, %d($sp)", p->symbol->offset * WSIZE);
    emit(fp, "", s, "Assign store RHS temporarily");
    emit_var(p->s1, fp); // $a0 now has the address of the variable
    sprintf(s, "lw $a1, %d($sp)", p->symbol->offset * WSIZE);
    emit(fp, "", s, "Assign get RHS temporarily");
    emit(fp, "", "sw $a1, ($a0)", "Assign place RHS into mempory");
    // fprintf(fp, "\n\n");
} // end of emit_assign

// PRE: PTR to ASTnode A_WHILE
// POST: MIPS code into the file for the tree
void emit_while(ASTnode *p, FILE *fp)
{
    char s[100];   // array for forming strings
    char *L1, *L2; // labels for the while loop

    L1 = createLabel(); // create a label for the start of the loop
    L2 = createLabel(); // create a label for the end of the loop

    sprintf(s, "%s", L1); // start of while loop
    emit(fp, s, "", "# Start of while loop");
    emit_expr(p->s1, fp); // evaluate the expression
    sprintf(s, "beq $a0, $0, %s", L2);
    emit(fp, "", s, "# End of while loop");
    EMIT_AST(p->s2, fp); // generate the compound statement
    sprintf(s, "j %s", L1); // jump back to the start of the loop
    emit(fp, "", s, "# Jump back to start of while loop");
    sprintf(s, "%s", L2); // end of while loop
    emit(fp, s, "", "#`End of while loop");
}

// PRE:  PTR to ASTnode A_IF
// POST: MIPS code into the file for the tree
void emit_if(ASTnode *p, FILE *fp)
{
    char s[100];   // array for forming strings
    char *L1, *L2; // labels for the if statement

    L1 = createLabel(); // create a label for the else target
    L2 = createLabel(); // create a label for the end of the if statement

    emit_expr(p->s1, fp); // evaluate the expression

    sprintf(s, "beq $a0, $0, %s", L1);
    emit(fp, "", s, "End of if statement");
    emit(fp, "", "\n", "Start of else statement");

    EMIT_AST(p->s2->s1, fp); // generate the compound statement
    sprintf(s, "j %s", L2);
    emit(fp, "", s, "s1 END");

    sprintf(s, "%s", L1);
    emit(fp, s, "", "ELSE TARGET");
    emit(fp, "", "", "otherwise just these lines");
    emit(fp, "", "", "End of then statement");
    EMIT_AST(p->s2->s2, fp); // generate the compound statement

    emit(fp, L2, "", "End of if statement");

} // end of emit_if

// PRE:  PTR to ASTnode A_RETURN
// POST: MIPS code into the file for the tree
void emit_return(ASTnode *p, FILE *fp)
{
    char s[100];
    if (p->s1 != NULL) // return has a value
    {

        emit_expr(p->s1, fp); // evaluate the expression
    }
    else // return has no value
    {

        emit(fp, "", "li $a0, 0", "RETURN has no specified value set to 0");
    }
    // restore RA and SP before we return
    emit(fp, "", "lw $ra ($sp)", "restore old environement RA");
    sprintf(s, "lw $sp %d($sp)", WSIZE);
    emit(fp, "", s, "Return from function store SP");
    fprintf(fp, "\n");

    if (strcmp(currentFunctionName, "main") == 0) //if main
    { // exit the system
        emit(fp, "", "li $v0, 10", "Exit from main we are done");
        emit(fp, "", "syscall\t", "EXIT everything");
    }
    else
    {
        // jump back to the caller
        emit(fp, "", "jr $ra", "return to caller");
    }
} // end of return

// PRE:  PTR to ASTnode for function call
// POST: Generates MIPS code for function call
void emit_call(ASTnode *p, FILE *fp)
{
    char s[100]; // Array for forming strings

    emit(fp, "", "", " Setting Up Function Call");
    emit(fp, "", "", " Evaluate function arguments");
    emit(fp, "", "", " place Parameters into T registers\n");


    ASTnode *arg = p->s1; // arguments
    int i = 0; // counter for register

    while (arg != NULL && i < 8) // evaluate arguments
    {
        emit_expr(arg->s1, fp); // evaluate the expression
        sprintf(s, "sw $a0, %d($sp)", arg->symbol->offset * WSIZE); // store argument
        emit(fp, "", s, "# Store argument");
        arg = arg->next; // next argument
        i++; // increment counter for register
    }

    // stored arguments to registers $t0 to $t7
    arg = p->s1;
    i = 0;
    while (arg != NULL && i < 8) // while there are arguments and temp registers are not full (LT 8)
    {
        sprintf(s, "lw $a0, %d($sp)", arg->symbol->offset * WSIZE); // retrieve argument
        emit(fp, "", s, "# Retrieve argument");
        sprintf(s, "move $t%d, $a0", i);
        emit(fp, "", s, "# Move argument to register");
        arg = arg->next; // next argument
        i++; // increment counter for register
    }

    // Call the function
    sprintf(s, "jal %s", p->name);
    emit(fp, "", s, "# Function call");
    fprintf(fp, "\n");
}

// PRE: PTR to ASTnode A_FUNCTIONDEC
// POST: MIPS code into the file for the tree
void emit_function(ASTnode *p, FILE *fp)
{
    char s[100];    
    currentFunctionName = p->name; //set the current function name for return

    emit(fp, p->name, "", "# function definition");
    // Carve out the stack for the activation record

    emit(fp, "", "move $a1, $sp", "Activation Record carve out copy SP");
    sprintf(s, "subi $a1, $a1, %d", p->symbol->offset * WSIZE);
    emit(fp, "", s, "Activation Record carve out copy size of function");
    emit(fp, "", "sw $ra, ($a1)", "Save the return address");
    sprintf(s, "sw $sp %d($a1)", WSIZE);
    emit(fp, "", s, "Store old Stack Pointer");
    emit(fp, "", "move $sp, $a1", "Make SP the current activation record");
    fprintf(fp, "\n\n");

    // copy the parameters to the formal from registers $t0

    ASTnode *arg = p->symbol->fparms; // arguments

    int x = 0;
    while (arg != NULL) //while there are arguments
    {
        sprintf(s, "sw $t%d %d($sp)", x, arg->symbol->offset * WSIZE);  //store the argument
        emit(fp, "", s, "Store the parameter in the activation record");
        arg = arg->next; // move to next argument
        x++; //increment counter for register 
    }

    fprintf(fp, "\n\n");

    // generate the compound statement
    EMIT_AST(p->s2, fp);

    // create an implicit return depending on if we
    // are main or not

    // restore RA and SP before we return
    emit(fp, "", "li $a0, 0", "RETURN has no specified value set to 0");
    emit(fp, "", "lw $ra, ($sp)", "Restore old enviornment RA");
    sprintf(s, "lw $sp, %d($sp)", WSIZE);
    emit(fp, "", s, "Return from function store SP");
    fprintf(fp, "\n\n");

    if (strcmp(p->name, "main") == 0)   //if main
    { // exit the system
        emit(fp, "", "li $v0, 10", "Exit from main we are done");   //exit
        emit(fp, "", "syscall\t", "EXIT everything");   //exit
    }
    else  //if not main
    {
        // jump back to the caller
        emit(fp, "", "jr $ra", "return to caller");
    }

    emit(fp, "", "\n\t", "End of function\n\n");

} // end of emit_function

// PRE:  PTR to ASTnode or NULL
// POST: MIPS code into the file for the tree
void EMIT_AST(ASTnode *p, FILE *fp)
{
    if (p == NULL)
        return;

    switch (p->type)
    {
    case A_VARDEC: // no real action
        EMIT_AST(p->next, fp);
        break;

    case A_COMPOUND: // no action for s1 vardecs -- already in stack size
        EMIT_AST(p->s2, fp);
        EMIT_AST(p->next, fp);
        break;

    case A_WRITE: // handled by helper function
        emit_write(p, fp);
        EMIT_AST(p->next, fp);
        break;

    case A_READ: // handled by helper function
        emit_read(p, fp);
        EMIT_AST(p->next, fp);
        break;

    case A_FUNCTIONDEC:
        emit_function(p, fp); // handled by helper function
        EMIT_AST(p->next, fp);
        break;

    case A_ASSIGN:
        emit_assign(p, fp); // handled by helper function
        EMIT_AST(p->next, fp);
        break;

    case A_WHILE:
        emit_while(p, fp); // handled by helper function
        EMIT_AST(p->next, fp);
        break;

    case A_IF:
        emit_if(p, fp); // handled by helper function
        EMIT_AST(p->next, fp);
        break;

    case A_RETURN:
        emit_return(p, fp); // handled by helper function
        EMIT_AST(p->next, fp);
        break;

    case A_CALL:
        emit_call(p, fp); // handled by helper function
        EMIT_AST(p->next, fp);
        break;

    case A_EXPRESSIONSTMT:
        emit_expr(p->s1, fp); // s1 because it is an expression
        EMIT_AST(p->next, fp);
        break;

    default:
        printf("EMIT_AST case %d not implemented\n", p->type);
        printf("WE SHOULD NEVER BE HERE\n");
        exit(1);

    } // end of switch

} // end of EMIT_AST
